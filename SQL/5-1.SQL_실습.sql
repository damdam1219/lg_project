-- DROP DATABASE IF EXISTS 분석실습;

CREATE DATABASE 분석실습 DEFAULT CHARSET  utf8mb4 COLLATE  utf8mb4_general_ci;

USE 분석실습;

CREATE TABLE CUSTOMER (
    mem_no INT PRIMARY KEY,
    last_name VARCHAR(20),
    first_name VARCHAR(20),
    gd CHAR(1),
    birth_dt DATE,
    entr_dt DATE,
    grade VARCHAR(10),
    sign_up_ch CHAR(2)
);

CREATE TABLE SALES (
    InvoiceNo VARCHAR(10),
    StockCode VARCHAR(20),
    Description VARCHAR(100),
    Quantity INT,
    InvoiceDate DATETIME,
    UnitPrice DECIMAL(10, 2),
    CustomerID INT,
    Country VARCHAR(50)
);

SELECT * FROM customer;

SELECT * FROM sales;

-- data를 지우고 새로 넣기위해
-- 외래키 제약이 있을 수 있으므로 제약을 잠시 끔
SET FOREIGN_KEY_CHECKS = 0;

-- 순서 주의: 자식 → 부모 테이블 순서로 삭제
DELETE FROM SALES;
DELETE FROM CUSTOMER;

-- 다시 제약 복원
SET FOREIGN_KEY_CHECKS = 1;

SELECT *
FROM CUSTOMER ;

SELECT *
FROM SALES;

-- 기간별 매출현황 
SELECT DATE(INVOICEDATE) AS 날짜
, SUM(UNITPRICE * QUANTITY) AS 매출액
, SUM(QUANTITY) AS 주문수량
, COUNT(DISTINCT INVOICENO) AS 주문건수
, COUNT(DISTINCT CUSTOMERID) AS 주문고객수
FROM SALES
GROUP BY DATE(INVOICEDATE)
ORDER BY DATE(INVOICEDATE) ;

-- 국가별 매출 현황
SELECT COUNTRY
, SUM(UNITPRICE * QUANTITY) AS 매출액
, SUM(QUANTITY) AS 주문수량
, COUNT(DISTINCT INVOICENO) AS 주문건수
, COUNT(DISTINCT CUSTOMERID) AS 주문고객수
FROM SALES
GROUP BY COUNTRY ;

-- 국가별, 제품별 매출현황
SELECT COUNTRY, STOCKCODE
, SUM(UNITPRICE * QUANTITY) AS 매출액
, SUM(QUANTITY) AS 주문수량
, COUNT(DISTINCT INVOICENO) AS 주문건수
, COUNT(DISTINCT CUSTOMERID) AS 주문고객수
FROM SALES
GROUP BY COUNTRY, STOCKCODE ;

-- 특정제품매출현황
SELECT SUM(UNITPRICE * QUANTITY) AS 매출액
, SUM(QUANTITY) AS 주문수량
, COUNT(DISTINCT INVOICENO) AS 주문건수
, COUNT(DISTINCT CUSTOMERID) AS 주문고객수
FROM SALES 
WHERE STOCKCODE = '21615' ;

-- 특정제품의 기간별 매출현황
SELECT INVOICEDATE
, SUM(UNITPRICE * QUANTITY) AS 매출액
, SUM(QUANTITY) AS 주문수량
, COUNT(DISTINCT INVOICENO) AS 주문건수
, COUNT(DISTINCT CUSTOMERID) AS 주문고객수
FROM SALES 
WHERE STOCKCODE IN ('21615','21731')
GROUP BY INVOICEDATE ;

-- 이벤트 효과분석
SELECT 
  CASE 
    WHEN INVOICEDATE BETWEEN '2011-09-05' AND '2011-09-10' THEN '이벤트기간'
    WHEN INVOICEDATE BETWEEN '2011-08-10' AND '2011-08-25' THEN '이벤트 비교 기간(전월동기간)'
  END AS 기간구분,
  SUM(UNITPRICE * QUANTITY) AS 매출액,
  SUM(QUANTITY) AS 주문수량,
  COUNT(DISTINCT INVOICENO) AS 주문건수,
  COUNT(DISTINCT CUSTOMERID) AS 주문고객수
FROM SALES
WHERE INVOICEDATE BETWEEN '2011-09-05' AND '2011-09-10'
   OR INVOICEDATE BETWEEN '2011-08-10' AND '2011-08-25'
GROUP BY 
  CASE 
    WHEN INVOICEDATE BETWEEN '2011-09-05' AND '2011-09-10' THEN '이벤트기간'
    WHEN INVOICEDATE BETWEEN '2011-08-10' AND '2011-08-25' THEN '이벤트 비교 기간(전월동기간)'
  END;

-- 이벤트 제품 효과 분석(시기에대한 비교)
SELECT 
  CASE 
    WHEN INVOICEDATE BETWEEN '2011-09-05' AND '2011-09-10' THEN '이벤트기간'
    WHEN INVOICEDATE BETWEEN '2011-08-10' AND '2011-08-25' THEN '이벤트 비교 기간(전월동기간)'
  END AS 기간구분,
  SUM(UNITPRICE * QUANTITY) AS 매출액,
  SUM(QUANTITY) AS 주문수량,
  COUNT(DISTINCT INVOICENO) AS 주문건수,
  COUNT(DISTINCT CUSTOMERID) AS 주문고객수
FROM SALES
WHERE INVOICEDATE BETWEEN '2011-09-05' AND '2011-09-10'
   OR INVOICEDATE BETWEEN '2011-08-10' AND '2011-08-25'
   AND STOCKCODE IN('17012A','17012C','17021','17084N')
GROUP BY 
  CASE 
    WHEN INVOICEDATE BETWEEN '2011-09-05' AND '2011-09-10' THEN '이벤트기간'
    WHEN INVOICEDATE BETWEEN '2011-08-10' AND '2011-08-25' THEN '이벤트 비교 기간(전월동기간)'
  END;
  
  -- 특정제품고매구객정보
SELECT C.CUSTOMERID
, S.COSTOMER_NAME
, S.GD
, S.BIRTH_DT
, S.ENTR_DT
, S.GRADE
, S.SIGN_UP_CH
FROM (
SELECT DISTINCT CUSTOMERID
FROM SALES 
WHERE STOCKCODE IN ('21730','21615')
AND INVOICEDATE BETWEEN '2010-12-01' AND '2010-12-10') C

LEFT JOIN (
SELECT MEM_NO
, CONCAT(LAST_NAME, FIRST_NAME) AS COSTOMER_NAME
, GD
, BIRTH_DT
, ENTR_DT
, GRADE
, SIGN_UP_CH
FROM CUSTOMER
) S
ON C.CUSTOMERID = S.MEM_NO ;

-- 미구매고객정보
SELECT CASE WHEN S.CUSTOMERID IS NULL THEN C.MEM_NO END AS NON_PURCHASER
, C.MEM_NO
, C.LAST_NAME
, C.FIRST_NAME
, S.INVOICENO
, S. STOCKCODE
, S.QUANTITY
, S.INVOICEDATE
, S.UNITPRICE
, S.CUSTOMERID
FROM CUSTOMER C
LEFT JOIN SALES S
ON C.MEM_NO = S.CUSTOMERID ;

-- 매출 평균 지표 종류
SELECT 
  SUM(UNITPRICE * QUANTITY) AS 매출액,
  SUM(QUANTITY) AS 주문수량,
  COUNT(DISTINCT INVOICENO) AS 주문건수,
  COUNT(DISTINCT CUSTOMERID) AS 주문고객수,
  SUM(UNITPRICE * QUANTITY) * 1.0 / COUNT(DISTINCT INVOICENO) AS AYV, -- 주문건당 평균 매출
  SUM(UNITPRICE * QUANTITY) * 1.0 / COUNT(DISTINCT CUSTOMERID) AS AMV, -- 고객당 평균 매출
  COUNT(DISTINCT INVOICENO) * 1.0 / COUNT(DISTINCT CUSTOMERID) AS AVGFRQ, -- 평균 구매 빈도수
  SUM(QUANTITY) * 1.0 / COUNT(DISTINCT INVOICENO) AS AVGUNITS -- 주문 1건당 평균 수량
FROM SALES;

-- 연도 및 월별 매출 평균지표의 값을 파악하기
SELECT YEAR(INVOICEDATE) AS 연도,
   MONTH (INVOICEDATE) AS 월,
  SUM(UNITPRICE * QUANTITY) AS 매출액,
  SUM(QUANTITY) AS 주문수량,
  COUNT(DISTINCT INVOICENO) AS 주문건수,
  COUNT(DISTINCT CUSTOMERID) AS 주문고객수,
  SUM(UNITPRICE * QUANTITY) * 1.0 / COUNT(DISTINCT INVOICENO) AS AYV, -- 주문건당 평균 매출
  SUM(UNITPRICE * QUANTITY) * 1.0 / COUNT(DISTINCT CUSTOMERID) AS AMV, -- 고객당 평균 매출
  COUNT(DISTINCT INVOICENO) * 1.0 / COUNT(DISTINCT CUSTOMERID) AS AVGFRQ, -- 평균 구매 빈도수
  SUM(QUANTITY) * 1.0 / COUNT(DISTINCT INVOICENO) AS AVGUNITS -- 주문 1건당 평균 수량
FROM SALES
GROUP BY YEAR(INVOICEDATE), MONTH (INVOICEDATE) 
ORDER BY 1,2 ;

-- 2011년 가장 많이 판매된 제품TOP10
SELECT STOCKCODE, DESCRIPTION , SUM(QUANTITY) AS QTY
FROM SALES 
WHERE YEAR(INVOICEDATE) = 2011
GROUP BY STOCKCODE, DESCRIPTION
ORDER BY QTY DESC
LIMIT 10;

-- 국가별로 가장 많이 판매된 제품
SELECT ROW_NUMBER() OVER(PARTITION BY COUNTRY ORDER BY QTY DESC) AS RNK,COUNTRY, STOCKCODE, DESCRIPTION,QTY
FROM ( SELECT COUNTRY, STOCKCODE, DESCRIPTION, SUM(QUANTITY) AS QTY FROM SALES
GROUP BY COUNTRY , STOCKCODE, DESCRIPTION) A
ORDER BY 2,1;

-- 20대 여성 고객이 가장 많이 구매한 제품 TOP 10
SELECT *
FROM (SELECT ROW_NUMBER() OVER(ORDER BY QTY DESC) AS RNK
		, STOCKCODE
		, DESCRIPTION
		, QTY
		FROM(SELECT STOCKCODE, DESCRIPTION,SUM(QUANTITY) AS QTY
				FROM SALES S
				LEFT JOIN CUSTOMER C
				ON S.CUSTOMERID = C.MEM_NO
				WHERE C.GD = 'F'
				AND 2023-YEAR(C.BIRTH_DT) BETWEEN '20' AND '29' -- 현재 23년도, (23-년도) 가 20~29세
				GROUP BY STOCKCODE, DESCRIPTION )A
		)AA
WHERE RNK <=10 ;

-- 장바구니 분석
-- 특정제품과 많이 구매한 제품 TOP 10

-- STEP1 -- 구매한 거래내역 확인
SELECT DISTINCT INVOICENO
FROM SALES
WHERE STOCKCODE = '20725';

-- STEP2-- 20725 제품을 제외한 구매제품확인
SELECT *
FROM SALES S
INNER JOIN (SELECT DISTINCT INVOICENO
			FROM SALES 
            WHERE STOCKCODE = '20725'
            ) I
ON S.INVOICENO = I.INVOICENO
WHERE S.STOCKCODE <> '20725' ;

-- STEP3 -- 특정 제품과 함께 구매한 제품의 주문수량을 구하고 주문 수량이 높은 순서대로 상위 10개
SELECT S. STOCKCODE, S.DESCRIPTION,SUM(QUANTITY) AS QTY
FROM SALES S
INNER JOIN(SELECT DISTINCT INVOICENO
			FROM SALES
            WHERE STOCKCODE = '20725'
            ) I 
ON S.INVOICENO = I.INVOICENO
WHERE S.STOCKCODE <> '20725'
GROUP BY S.STOCKCODE, S.DESCRIPTION
ORDER BY QTY DESC ;

-- LUNCH 가 포함된 제품을 제외하는 조건 추가
SELECT S. STOCKCODE, S.DESCRIPTION,SUM(QUANTITY) AS QTY
FROM SALES S
INNER JOIN(SELECT DISTINCT INVOICENO
			FROM SALES
            WHERE STOCKCODE = '20725'
            ) I 
ON S.INVOICENO = I.INVOICENO
WHERE S.STOCKCODE <> '20725' AND S.DESCRIPTION NOT LIKE '%LUNCH%'
GROUP BY S.STOCKCODE, S.DESCRIPTION
ORDER BY QTY DESC ;

-- 쇼핑물의 재구매지표 롹인
SELECT COUNT(DISTINCT CUSTOMERID) AS REPURCHASER_COUNT
FROM( SELECT CUSTOMERID, COUNT(DISTINCT INVOICEDATE) AS FRQ
		FROM SALES 
		WHERE CUSTOMERID <>''
		GROUP BY CUSTOMERID
		HAVING COUNT(DISTINCT INVOICEDATE) >=2) A ;

-- 특정제품의 재구매 고객수와 구매일자 순서를 확인하고 싶습니다.
SELECT COUNT(DISTINCT CUSTOMERID) AS REPURCHASER_COUNT
FROM( SELECT CUSTOMERID, DENSE_RANK() OVER (PARTITION BY CUSTOMERID ORDER BY INVOICEDATE) AS RNK
		FROM SALES
		WHERE CUSTOMERID <> ''
		AND STOCKCODE = '21088') A
WHERE RNK = 2 ;

-- 2010년 구매이력이 있는 고객들의 2011년 유지율을 확인
SELECT COUNT(DISTINCT CUSTOMERID) AS RETENTION_CUSTOMER_COUNT
FROM SALES
WHERE CUSTOMERID <> ''
AND CUSTOMERID IN (SELECT CUSTOMERID 	
					FROM SALES
                    WHERE CUSTOMERID <> ''
                    AND YEAR(INVOICEDATE) = '2010')
AND YEAR(INVOICEDATE) = '2011' ;
                    
                    -- STEP1: 고객별로 제품을 구매한 순서를 정한다.
SELECT CUSTOMERID,
       INVOICEDATE,
       DENSE_RANK() OVER (PARTITION BY CUSTOMERID ORDER BY INVOICEDATE) AS DAY_NO
FROM (
    SELECT CUSTOMERID, INVOICEDATE
    FROM SALES
    WHERE CUSTOMERID <> ''
    GROUP BY CUSTOMERID, INVOICEDATE
) A;

-- STEP2: STEP1에서 확인한 순서를 바탕으로 첫 구매와 재구매 기간을 확인한다.
SELECT 
    AA.CUSTOMERID AS FIRST_PUR_CUSTOMERID,
    AA.INVOICEDATE AS FIRST_PUR_INVOICEDATE,
    AA.DAY_NO AS FIRST_PUR_DAY_NO,
    BB.CUSTOMERID AS SECOND_PUR_CUSTOMERID,
    BB.INVOICEDATE AS SECOND_PUR_INVOICEDATE,
    BB.DAY_NO AS SECOND_PUR_DAY_NO
FROM (
    SELECT 
        CUSTOMERID,
        INVOICEDATE,
        DENSE_RANK() OVER (PARTITION BY CUSTOMERID ORDER BY INVOICEDATE) AS DAY_NO
    FROM (
        SELECT 
            CUSTOMERID,
            INVOICEDATE
        FROM SALES
        WHERE CUSTOMERID <> ''
        GROUP BY CUSTOMERID, INVOICEDATE
    ) A
) AA
LEFT JOIN (
    SELECT 
        CUSTOMERID,
        INVOICEDATE,
        DENSE_RANK() OVER (PARTITION BY CUSTOMERID ORDER BY INVOICEDATE) AS DAY_NO
    FROM (
        SELECT 
            CUSTOMERID,
            INVOICEDATE
        FROM SALES
        WHERE CUSTOMERID <> ''
        GROUP BY CUSTOMERID, INVOICEDATE
    ) B
) BB
    ON AA.CUSTOMERID = BB.CUSTOMERID
    AND AA.DAY_NO + 1 = BB.DAY_NO
WHERE AA.DAY_NO = 1
  AND BB.DAY_NO = 2;

-- STEP3: 첫 구매와 재구매 기간의 차이를 계산한다.
SELECT 
    AA.CUSTOMERID AS FIRST_PUR_CUSTOMERID,
    AA.INVOICEDATE AS FIRST_PUR_INVOICEDATE,
    AA.DAY_NO AS FIRST_PUR_DAY_NO,
    BB.CUSTOMERID AS SECOND_PUR_CUSTOMERID,
    BB.INVOICEDATE AS SECOND_PUR_INVOICEDATE,
    BB.DAY_NO AS SECOND_PUR_DAY_NO,
    DATEDIFF(BB.INVOICEDATE, AA.INVOICEDATE) AS PURCHASE_PERIOD
FROM (
    SELECT 
        CUSTOMERID,
        INVOICEDATE,
        DENSE_RANK() OVER (PARTITION BY CUSTOMERID ORDER BY INVOICEDATE) AS DAY_NO
    FROM (
        SELECT 
            CUSTOMERID,
            INVOICEDATE
        FROM SALES
        WHERE CUSTOMERID <> ''
        GROUP BY CUSTOMERID, INVOICEDATE
    ) A
) AA
LEFT JOIN (
    SELECT 
        CUSTOMERID,
        INVOICEDATE,
        DENSE_RANK() OVER (PARTITION BY CUSTOMERID ORDER BY INVOICEDATE) AS DAY_NO
    FROM (
        SELECT CUSTOMERID, INVOICEDATE
        FROM SALES
        WHERE CUSTOMERID <> ''
        GROUP BY CUSTOMERID, INVOICEDATE
    ) B
) BB
    ON AA.CUSTOMERID = BB.CUSTOMERID AND AA.DAY_NO + 1 = BB.DAY_NO
WHERE AA.DAY_NO = 1
  AND BB.DAY_NO = 2;

-- STEP4: 구매 기간 차이 일수의 평균을 구하는 집계.
SELECT AVG(PURCHASE_PERIOD) AS AVG_PURCHASE_PERIOD
FROM (
    SELECT 
        AA.CUSTOMERID AS FIRST_PUR_CUSTOMERID,
        AA.INVOICEDATE AS FIRST_PUR_INVOICEDATE,
        AA.DAY_NO AS FIRST_PUR_DAY_NO,
        BB.CUSTOMERID AS SECOND_PUR_CUSTOMERID,
        BB.INVOICEDATE AS SECOND_PUR_INVOICEDATE,
        BB.DAY_NO AS SECOND_PUR_DAY_NO,
        DATEDIFF(BB.INVOICEDATE, AA.INVOICEDATE) AS PURCHASE_PERIOD
    FROM (
        SELECT CUSTOMERID, INVOICEDATE,
               DENSE_RANK() OVER (PARTITION BY CUSTOMERID ORDER BY INVOICEDATE) AS DAY_NO
        FROM (
            SELECT CUSTOMERID, INVOICEDATE
            FROM SALES
            WHERE CUSTOMERID <> ''
            GROUP BY CUSTOMERID, INVOICEDATE
        ) A
    ) AA
    LEFT JOIN (
        SELECT CUSTOMERID, INVOICEDATE,
               DENSE_RANK() OVER (PARTITION BY CUSTOMERID ORDER BY INVOICEDATE) AS DAY_NO
        FROM (
            SELECT CUSTOMERID, INVOICEDATE
            FROM SALES
            WHERE CUSTOMERID <> ''
            GROUP BY CUSTOMERID, INVOICEDATE
        ) B
    ) BB
        ON AA.CUSTOMERID = BB.CUSTOMERID 
        AND AA.DAY_NO + 1 = BB.DAY_NO
    WHERE AA.DAY_NO = 1
      AND BB.DAY_NO = 2
) AAA;

